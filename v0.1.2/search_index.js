var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DataTools","category":"page"},{"location":"#DataTools","page":"Home","title":"DataTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DataTools]","category":"page"},{"location":"#DataTools.DataTools","page":"Home","title":"DataTools.DataTools","text":"DataTools: manipulating flat tables and nested data structures using Transducers.jl\n\n(Image: Dev) (Image: GitHub Actions)\n\njulia> using DataTools: oncol, modifying, averaging\n\njulia> using Transducers: Filter\n\njulia> data = [(a = 1, b = 7), (a = 2, b = 3), (a = 3, b = 4)];\n\njulia> rf = oncol(a = +, b = averaging);\n\njulia> foldl(rf, Filter(x -> isodd(x.a)), data)\n(a = 4, b = 5.5)\n\njulia> map(modifying(a = string), data)\n3-element Array{NamedTuple{(:a, :b),Tuple{String,Int64}},1}:\n (a = \"1\", b = 7)\n (a = \"2\", b = 3)\n (a = \"3\", b = 4)\n\njulia> reduce(modifying(a = +), data)\n(a = 6, b = 7)\n\njulia> using Setfield: @lens\n\njulia> data = [(a = ((b = 1,), 2),), (a = ((b = 3,), 4),)];\n\njulia> map(modifying(@lens(_.a[1].b) => x -> 10x), data)\n2-element Array{NamedTuple{(:a,),Tuple{Tuple{NamedTuple{(:b,),Tuple{Int64}},Int64}}},1}:\n (a = ((b = 10,), 2),)\n (a = ((b = 30,), 4),)\n\n\n\n\n\n","category":"module"},{"location":"#DataTools.averaging","page":"Home","title":"DataTools.averaging","text":"averaging\n\nA reducing function for averaging elements.\n\nExamples\n\njulia> using DataTools\n       using Transducers\n\njulia> foldl(averaging, Filter(isodd), 1:10)\n5.0\n\njulia> rf = oncol(a = averaging, b = averaging);\n\njulia> foldl(rf, Map(identity), [(a = 1, b = 2), (a = 2, b = 3)])\n(a = 1.5, b = 2.5)\n\n\n\n\n\n","category":"function"},{"location":"#DataTools.inc1-Tuple{Any,Any}","page":"Home","title":"DataTools.inc1","text":"inc1(n, _) -> n + 1\n\nA reducing function for counting elements.  It increments the first argument by one.\n\nExamples\n\njulia> using DataTools\n       using Transducers\n\njulia> inc1(10, :ignored)\n11\n\njulia> inc1(Init(inc1), :ignored)\n1\n\njulia> foldl(inc1, Map(identity), 'a':2:'e')\n3\n\njulia> foldl(TeeRF(+, inc1), Map(identity), 1:2:10)  # sum and count\n(25, 5)\n\njulia> rf = oncol(:a => (+) => :sum, :a => inc1 => :count);\n\njulia> foldl(rf, Map(identity), [(a = 1, b = 2), (a = 2, b = 3)])\n(sum = 3, count = 2)\n\n\n\n\n\n","category":"method"},{"location":"#DataTools.meanvar","page":"Home","title":"DataTools.meanvar","text":"meanvar\n\nA reducing function for computing the mean and variance.\n\nExamples\n\njulia> using DataTools, Transducers, Statistics\n\njulia> acc = foldl(meanvar, Filter(isodd), 1:96)\nMeanVarState(mean=48.0, var=784.0, count=48)\n\njulia> acc.mean, mean(acc)\n(48.0, 48.0)\n\njulia> acc.var, var(acc), var(acc, corrected = false)\n(784.0, 784.0, 767.6666666666666)\n\njulia> acc.std, std(acc)\n(28.0, 28.0)\n\njulia> acc.count\n48\n\njulia> m, v, c = acc;  # destructuring works\n\njulia> Tuple(acc)  # (mean, var, count)\n(48.0, 784.0, 48)\n\njulia> NamedTuple(acc)\n(mean = 48.0, var = 784.0, count = 48)\n\njulia> rf = oncol(a = meanvar, b = meanvar);\n\njulia> foldl(rf, Map(identity), [(a = 1, b = 2), (a = 2, b = 3)])\n(a = MeanVarState(mean=1.5, var=0.5, count=2), b = MeanVarState(mean=2.5, var=0.5, count=2))\n\n\n\n\n\n","category":"function"},{"location":"#DataTools.modifying","page":"Home","title":"DataTools.modifying","text":"modifying(; $property₁ = f₁, ..., $propertyₙ = fₙ) -> g::Function\nmodifying(lens₁ => f₁, ..., lensₙ => fₙ) -> g::Function\n\nCreate a function that runs function fᵢ on the locations specified by propertyᵢ or lensᵢ.\n\nThe keyword-only method modifying(; a = f₁, b = f₂) is equivalent to modifying(@len(_.a) => f₁, @len(_.b) => f₂).\n\nThe unary method g(x) is equivalent to\n\nx = modify(f₁, x, lens₁)\nx = modify(f₂, x, lens₂)\n...\nx = modify(fₙ, x, lensₙ)\n\nThe binary method g(x, y) is equivalent to\n\nx = set(x, lens₁, f₁(get(x, lens₁), get(y, lens₁)))\nx = set(x, lens₂, f₂(get(x, lens₂), get(y, lens₂)))\n...\nx = set(x, lensₙ, fₙ(get(x, lensₙ), get(y, lensₙ)))\n\nNote that the locations that are not specified by the lenses keep the values as in x.  This is similar to how mergewith behaves.\n\nExamples\n\njulia> using DataTools\n\njulia> map(modifying(a = string), [(a = 1, b = 2), (a = 3, b = 4)])\n2-element Array{NamedTuple{(:a, :b),Tuple{String,Int64}},1}:\n (a = \"1\", b = 2)\n (a = \"3\", b = 4)\n\njulia> reduce(modifying(a = +), [(a = 1, b = 2), (a = 3, b = 4)])\n(a = 4, b = 2)\n\njulia> using Setfield\n\njulia> map(modifying(@lens(_.a[1].b) => x -> 10x),\n           [(a = ((b = 1,), 2),), (a = ((b = 3,), 4),)])\n2-element Array{NamedTuple{(:a,),Tuple{Tuple{NamedTuple{(:b,),Tuple{Int64}},Int64}}},1}:\n (a = ((b = 10,), 2),)\n (a = ((b = 30,), 4),)\n\n\n\n\n\n","category":"function"},{"location":"#DataTools.oncol","page":"Home","title":"DataTools.oncol","text":"oncol(iname₁ => spec₁, ..., inameₙ => specₙ) -> f::Function\noncol(; $iname₁ = spec₁, ..., $inameₙ = specₙ) -> f::Function\n\nCombine functions that work on a column and create a function that work on an entire row.\n\nIt constructs a reducing step function acting on a table row where specᵢ is either a reducing step function or a Pair of a reducing step function and an output column name.\n\nIt also defines a unary function when specᵢ is either a unary function or a Pair of a unary function and an output column name.\n\nThis function is inspired by the \"Pair notation\" in DataFrames.jl (see also Split-apply-combine · DataFrames.jl and DataFrames.select).\n\nExamples\n\njulia> using DataTools\n       using Transducers\n\njulia> rf = oncol(a = +, b = *);\n\njulia> foldl(rf, Map(identity), [(a = 1, b = 2), (a = 3, b = 4)])\n(a = 4, b = 8)\n\njulia> rf((a = 1, b = 2), (a = 3, b = 4))\n(a = 4, b = 8)\n\njulia> rf = oncol(:a => (+) => :sum, :a => max => :max);\n\njulia> foldl(rf, Map(identity), [(a = 1,), (a = 2,)])\n(sum = 3, max = 2)\n\njulia> rf((sum = 1, max = 1), (a = 2,))\n(sum = 3, max = 2)\n\njulia> rf = oncol(:a => min, :a => max);\n\njulia> foldl(rf, Map(identity), [(a = 2,), (a = 1,)])\n(a_min = 1, a_max = 2)\n\njulia> rf((a_min = 2, a_max = 2), (a = 1,))\n(a_min = 1, a_max = 2)\n\njulia> foldl(rf, Map(x -> (a = x,)), [5, 2, 6, 8, 3])\n(a_min = 2, a_max = 8)\n\noncol also defines a unary function\n\njulia> f = oncol(a = string);\n\njulia> f((a = 1, b = 2))\n(a = \"1\",)\n\nNote that oncol does not verify the arity of input functions.  If the input functions have unary and binary methods, oncol is callable with both arities:\n\njulia> f((a = 1, b = 2), (a = 3, b = 4))\n(a = \"13\",)\n\n\n\n\n\n","category":"function"},{"location":"#DataTools.rightif","page":"Home","title":"DataTools.rightif","text":"rightif(predicate, [focus = identity]) -> op::Function\n\nReturn a binary function that keeps the first argument unless predicate evaluates to true.\n\nThis is equivalent to\n\n(l, r) -> predicate(focus(l), focus(r)) ? r : l\n\nExamples\n\njulia> using DataTools, Transducers\n\njulia> table = 1:100 |> Map(x -> (k = gcd(x, 42), v = x));\n\njulia> table |> Take(5) |> collect  # preview\n5-element Array{NamedTuple{(:k, :v),Tuple{Int64,Int64}},1}:\n (k = 1, v = 1)\n (k = 2, v = 2)\n (k = 3, v = 3)\n (k = 2, v = 4)\n (k = 1, v = 5)\n\njulia> foldl(rightif(<), Map(x -> x.k), table)  # maximum\n42\n\njulia> foldl(rightif(>), Map(x -> x.k), table)  # minimum\n1\n\njulia> foldl(rightif(<, x -> x.k), table)   # first maximum\n(k = 42, v = 42)\n\njulia> foldl(rightif(<=, x -> x.k), table)  # last maximum\n(k = 42, v = 84)\n\njulia> foldl(rightif(>, x -> x.k), table)   # first minimum\n(k = 1, v = 1)\n\njulia> foldl(rightif(>=, x -> x.k), table)  # last minimum\n(k = 1, v = 97)\n\njulia> table |> Scan(rightif(<, x -> x.k)) |> Take(5) |> collect\n5-element Array{NamedTuple{(:k, :v),Tuple{Int64,Int64}},1}:\n (k = 1, v = 1)\n (k = 2, v = 2)\n (k = 3, v = 3)\n (k = 3, v = 3)\n (k = 3, v = 3)\n\n\n\n\n\n","category":"function"}]
}
